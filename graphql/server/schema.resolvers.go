package server

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"math"

	"github.com/ecshreve/jepp/graphql/models"
	"github.com/ecshreve/jepp/graphql/models/gen"
	gqlserver "github.com/ecshreve/jepp/graphql/server/generated"
)

// Season is the resolver for the season field.
func (r *queryResolver) Season(ctx context.Context, seasonID int64) (*models.Season, error) {
	var season models.Season
	if err := r.DB.First(&season, seasonID).Error; err != nil {
		return nil, err
	}

	return &season, nil
}

// Seasons is the resolver for the seasons field.
func (r *queryResolver) Seasons(ctx context.Context) ([]*models.Season, error) {
	var seasons []*models.Season
	if err := r.DB.Find(&seasons).Error; err != nil {
		return nil, err
	}

	return seasons, nil
}

// Clue is the resolver for the clue field.
func (r *queryResolver) Clue(ctx context.Context, clueID int64) (*models.Clue, error) {
	var clue models.Clue
	if err := r.DB.First(&clue, clueID).Error; err != nil {
		return nil, err
	}

	return &clue, nil
}

// Clues is the resolver for the clues field.
func (r *queryResolver) Clues(ctx context.Context, first *int64, after *int64) (*gen.CluesPaginated, error) {
	decodedCursor := 0
	if after != nil {
		decodedCursor = int(*after)
	}

	bound := int(math.Max(float64(int64(*first)), 10))

	var clues []*models.Clue
	if err := r.DB.Limit(bound+1).Order("id asc").Where("id > ?", decodedCursor).Find(&clues).Error; err != nil {
		return nil, err
	}

	hasNextPage := len(clues) > bound

	pageInfo := gen.PageInfo{
		StartCursor: clues[0].ID,
		EndCursor:   clues[len(clues)-1].ID,
		HasNextPage: &hasNextPage,
	}

	return &gen.CluesPaginated{
		Nodes:    clues,
		PageInfo: &pageInfo,
	}, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, categoryID int64) (*models.Category, error) {
	var category models.Category
	if err := r.DB.First(&category, categoryID).Error; err != nil {
		return nil, err
	}

	return &category, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, first *int64, after *int64) (*gen.CategoriesPaginated, error) {
	decodedCursor := 0
	if after != nil {
		decodedCursor = int(*after)
	}
	bound := int(math.Max(float64(int64(*first)), 10))

	var categories []*models.Category
	if err := r.DB.Limit(bound+1).Order("id asc").Where("id > ?", decodedCursor).Find(&categories).Error; err != nil {
		return nil, err
	}

	hasNextPage := len(categories) > bound

	pageInfo := gen.PageInfo{
		StartCursor: categories[0].ID,
		EndCursor:   categories[len(categories)-1].ID,
		HasNextPage: &hasNextPage,
	}

	return &gen.CategoriesPaginated{
		Nodes:    categories,
		PageInfo: &pageInfo,
	}, nil
}

// Game is the resolver for the game field.
func (r *queryResolver) Game(ctx context.Context, gameID int64) (*models.Game, error) {
	var game models.Game
	if err := r.DB.First(&game, gameID).Error; err != nil {
		return nil, err
	}

	return &game, nil
}

// Games is the resolver for the games field.
func (r *queryResolver) Games(ctx context.Context, first *int64, after *int64) (*gen.GamesPaginated, error) {
	decodedCursor := 0
	if after != nil {
		decodedCursor = int(*after)
	}
	bound := int(math.Max(float64(int64(*first)), 10))

	var games []*models.Game
	if err := r.DB.Limit(bound+1).Order("id asc").Where("id > ?", decodedCursor).Find(&games).Error; err != nil {
		return nil, err
	}

	hasNextPage := len(games) > bound

	pageInfo := gen.PageInfo{
		StartCursor: games[0].ID,
		EndCursor:   games[len(games)-1].ID,
		HasNextPage: &hasNextPage,
	}

	return &gen.GamesPaginated{
		Nodes:    games,
		PageInfo: &pageInfo,
	}, nil
}

// Query returns gqlserver.QueryResolver implementation.
func (r *Resolver) Query() gqlserver.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
